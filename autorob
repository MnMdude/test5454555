-- Wait until the game is fully loaded
task.wait()

local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local TeleportService = game:GetService("TeleportService")
local Player = game.Players.LocalPlayer

local flyspeed = getgenv().FlySpeed or 50
local retryLimit = 5  -- Retry limit for server hop
local minPlayers = getgenv().ServerHop and getgenv().ServerHop.min or 5
local maxPlayers = getgenv().ServerHop and getgenv().ServerHop.max or 25

-- Function to retrieve the list of available servers
local function getServerList(cursor)
    local placeId = game.PlaceId
    local apiUrl = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?sortOrder=Desc&limit=100"
    if cursor then apiUrl = apiUrl .. "&cursor=" .. cursor end

    for attempt = 1, retryLimit do
        local success, response = pcall(function()
            return game:HttpGet(apiUrl)
        end)
        
        if success then
            local decodedResponse = HttpService:JSONDecode(response)
            if decodedResponse and decodedResponse.data and #decodedResponse.data > 0 then
                return decodedResponse  -- Valid response with server data
            else
                warn("No servers found, retrying... (Attempt " .. attempt .. ")")
            end
        else
            warn("Failed to retrieve server list (Attempt " .. attempt .. "): " .. response)
        end
        task.wait(3)  -- Wait before retrying
    end

    return nil  -- Return nil if all attempts fail
end

-- Enhanced server hopping function
local function serverHop()
    local placeId, jobId = game.PlaceId, game.JobId
    local nextCursor = nil
    local retryCount = 0

    while retryCount < retryLimit do
        local servers = getServerList(nextCursor)

        if servers and servers.data then
            for _, server in pairs(servers.data) do
                -- Check if the server has a valid player count and is not the current server
                if server.playing >= minPlayers and server.playing <= maxPlayers and server.id ~= jobId then
                    -- Attempt to teleport to the selected server
                    local success, result = pcall(function()
                        return TeleportService:TeleportToPlaceInstance(placeId, server.id, Player)
                    end)
                    if success then
                        print("Successfully hopped to server: " .. server.id)
                        return  -- Exit after successful teleport
                    else
                        warn("Failed to teleport: " .. result)
                    end
                end
            end
            nextCursor = servers.nextPageCursor
        else
            retryCount = retryCount + 1
            warn("No valid servers found, retrying... (Retry " .. retryCount .. "/" .. retryLimit .. ")")
            task.wait(5)  -- Increase wait time before retrying
        end

        if not nextCursor then
            print("No more servers to hop to.")
            break  -- Exit if no more servers are available
        end
    end

    warn("Server hop failed after " .. retryLimit .. " retries.")
end

-- Robbery items to look for
local MiniRobberies = {"Cash", "CashRegister", "DiamondBox", "Laptop", "Phone", "Luggage", "ATM", "TV", "Safe"}

-- Function to handle teleporting to a robbery object
local function tweenToPosition(pos, speed)
    local hrp = Player.Character:WaitForChild("HumanoidRootPart")
    local distance = (hrp.Position - pos).Magnitude
    local tweenInfo = TweenInfo.new(distance / speed)

    local tween = TweenService:Create(hrp, tweenInfo, {Position = pos})
    tween:Play()
    tween.Completed:Wait()
end

-- Function to steal from the closest available robbery
local function attemptRobbery()
    local hrp = Player.Character:WaitForChild("HumanoidRootPart")
    local closestRobbery, closestDistance = nil, math.huge

    -- Find closest valid robbery
    for _, object in pairs(workspace.ObjectSelection:GetChildren()) do
        if table.find(MiniRobberies, object.Name) and not object:FindFirstChild("Nope") and object:IsDescendantOf(workspace) then
            local objectPosition = object:GetPivot().Position
            local distance = (hrp.Position - objectPosition).Magnitude
            if distance < closestDistance then
                closestDistance = distance
                closestRobbery = object
            end
        end
    end

    if closestRobbery then
        local robberyPos = closestRobbery:GetPivot().Position
        local event = closestRobbery:FindFirstChildWhichIsA("RemoteEvent", true)

        -- Validate robbery object and position
        if robberyPos and event then
            -- Move to robbery and steal
            tweenToPosition(robberyPos, flyspeed)
            event:FireServer()
            print("Stolen from: " .. closestRobbery.Name)
        else
            warn("Failed to teleport or find event for: " .. closestRobbery.Name)
        end
    else
        warn("No valid robbery found.")
    end
end

-- Function to clean unnecessary parts from the game world
local function cleanGameWorld()
    local IgnoreFolder = workspace:WaitForChild("Ignore")
    IgnoreFolder:WaitForChild("ComputerStore"):WaitForChild("Lasers"):Destroy()
    IgnoreFolder:WaitForChild("JewelryStore"):WaitForChild("Jewlery"):WaitForChild("Lasers"):Destroy()

    for _, obj in pairs(IgnoreFolder.WorldObjects:GetChildren()) do
        if obj.Name == "Lasers" then
            obj:Destroy()
        end
    end
end

-- Initial setup and cleanup
task.spawn(function()
    task.wait(40)
    serverHop()  -- Try to hop servers after initial delay
end)

task.wait(getgenv().TimeToLoad or 5)

-- Clean the game world
cleanGameWorld()

-- Robbery loop
task.spawn(function()
    while true do
        attemptRobbery()
        task.wait(0.1)  -- Increased wait time to reduce spamming the robbery event
    end
end)

-- Server hopping loop every 30 seconds
task.spawn(function()
    while true do
        task.wait(30)
        serverHop()  -- Try to hop every 30 seconds
    end
end)
